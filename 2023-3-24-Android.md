# 2023-3-24

## 应用基础知识

### 应用组件

这是Android应用的基本构建块：

- `Activity`
- `服务`
- `广播接收器`
- `内容提供程序`

#### Activity

​	这是**与用户交互**的入口点，它表示拥有界面的单个屏幕。

​	它有助于完成系统和应用程序之间的重要交互

- 追踪用户当前关心的内容，以确保系统继续运行托管Activity的进程
- 了解先前使用的进程包含用户可能返回的内容，从而更优先保留这些进程
- 帮助应用处理终止其进程的情况，以便于用户可以返回已恢复其先前状态的Activity
- 提供一种途径，让应用实现彼此之间的用户流，并且让系统协调这些用户流

#### 服务

​	服务是一个**通用**入口点，用于各种原因使得应用在后台保持运行状态，它是一种在后	台运行的组件，用于执行长时间的操作或为远程进程执行作业。

​	服务并不提供界面。

​	绑定服务之所以可以运行，原因是某些其他应用以表示希望使用该服务。根本上讲，	这是为另外一个进程提供API的服务，因此，系统会知晓这些进程存在依赖关系。

​	由于这灵活性，服务已经成为非常有用的构建块，并且可以实现各种高级系统概念。

​	服务需要==Service==的子类来实现

#### 广播接收器

​	借助这个组件，系统能够在常规用户流之外向应用传递事件，从而允许应用响应系统	范围内的广播通知。

​	由于广播接收器是另外一个明确定义的应用入口，因此系统甚至可以向当前未运行的	应用传递广播。

​	广播不会显示界面，但是它可以**创建状态栏通知**，但是广播接收器更常见的用途只是	作为通向其他组件的通道，旨在执行极少量的工作。

​	广播接收器作为`BroadcastReceiver`的子类实现，并且每条广播都作为`Intent`对象	进行传递

#### 内容提供程序

​	它管理一组共享的应用数据，可以将这些数据存储在文件系统、SQLite数据库、网络	中或者应用可以访问的任何其他持久化存储的位置。其他应用可通过内容提供程序查	询或修改数据（如果内容提供程序允许）。

​	内容提供程序作为`ContentProvider`的子类实现，并且其必须实现一组标准API，以	便于其他应用能够执行事务。

**Android**系统设计的独特之处在于，任何应用都可启动其他应用的组件。

当系统启动某个组件的时候，它会启动该应用的进程，并且实例化该组件所需要的类。因此，与大多数其他系统的应用不同，Android应用并没有单个入口点（即没有`main()`函数）。

### 启动组件

在四种组件类型中，有三种（Activity、服务和广播接收器）均通过异步消息==Intent==进行启动。它会在运行时对各个组件进行相互绑定，您可以将Intent视为从其他组件请求操作的信使。

每个组件有不同的启动方法：

- ==Activity==，可以向`startActivity()`或者`startActivityForResult()`传递`Intent`，或者为其安排其他新任务。
- 在API级别21之后，可以使用`JobScheduler`类来调度操作。对于早期的版本，通过`startService()`传递`Intent`来启动服务。也可以通过向`bindService()`传递`Intent`来绑定到该服务。

- 您可以通过向 `sendBroadcast()`、`sendOrderedBroadcast()` 或 `sendStickyBroadcast()` 等方法传递 `Intent` 来发起广播。
- 您可以通过在 `ContentResolver` 上调用 `query()`，对内容提供程序执行查询。

### 清单文件

在Android系统启动应用组件之前，系统必须通过读取应用的清单文件（**AndroidManifest.xml**）来确认组件存在。这个文件必须位于应用项目目录的根目录中。

其他作用：

- 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限。
- 根据应用使用的 API，声明应用所需的最低 [API 级别](https://developer.android.com/guide/topics/manifest/uses-sdk-element?hl=zh-cn#ApiLevels)。
- 声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕。
- 声明应用需要链接的 API 库（Android 框架 API 除外），如 [Google 地图库](http://code.google.com/android/add-ons/google-apis/maps-overview.html?hl=zh-cn)。

#### 声明组件

清单文件主要任务就是告知系统应用组件的相关信息。

```kotlin
<?xml version="1.0" encoding="utf-8"?>
<manifest ... >
    <application android:icon="@drawable/app_icon.png" ... >
        <activity android:name="com.example.project.ExampleActivity"
                  android:label="@string/example_label" ... >
        </activity>
        ...
    </application>
</manifest>
```

在 `<application>` 元素中，`android:icon` 属性指向标识应用的图标所对应的资源。

在 `<activity>` 元素中，`android:name` 属性指定 `Activity` 子类的完全限定类名，`android:label` 属性指定用作 Activity 的用户可见标签的字符串。

元素声明所有应用组件：

- Activity 的 `<activity>` 元素。
- 服务的 `<service>` 元素。
- 广播接收器的 `<receiver>` 元素。
- 内容提供程序的 `<provider>` 元素。

### 应用资源

Android 应用并非仅包含代码，它还需要与源代码分离的资源，如图像、音频文件以及任何与应用的视觉呈现有关的内容。例如，可以通过 XML 文件定义 Activity 界面的动画、菜单、样式、颜色和布局。借助应用资源，无需修改代码即可轻松更新应用的各种特性。通过提供备用资源集，可以针对各种设备配置（如不同的语言和屏幕尺寸）优化应用。

对于您在 Android 项目中加入的每一项资源，SDK 构建工具均会定义唯一的整型 ID，可以利用此 ID 来引用资源，这些资源或来自应用代码，或来自 XML 中定义的其他资源。例如，如果应用中包含名为 `logo.png` 的图像文件（保存在 `res/drawable/` 目录中），则 SDK 工具会生成名为 `R.drawable.logo` 的资源 ID。此 ID 映射到应用特定的整型数，可以利用它来引用该图像，并将其插入界面。

如果提供与源代码分离的资源，则其中最重要的一个优点在于，可以提供适用于不同设备配置的备用资源。例如，通过在 XML 中定义界面字符串，可以将字符串翻译为其他语言，并将这些字符串保存在单独的文件中。然后，Android 系统会根据向资源目录名称追加的语言*限定符*（如为法语字符串值追加 `res/values-fr/`）和用户的语言设置，对界面应用相应的语言字符串。

Android 支持许多不同的备用资源*限定符*。限定符是资源目录名称中加入的短字符串，用于定义这些资源适用的设备配置。

## 移动应用用户体验

典型的Android应用包含多个应用组件，包括：Activity、Fragment、Service、内容提供程序和广播接收器。

移动设备的资源很有限，因此操作系统可能随时终止某些应用进程以便为新的进程腾出空间。

鉴于这种环境条件，应用组件可以不按顺序地单独启动，并且操作系统或者用户可以随时销毁它们。由于这些事件不受控制，所以不应该在内存中存储或者保留任何应用数据或者状态，并且应用组件不应相互依赖。

### 常见的架构原则

#### 分离关注点

==最重要的原则==

一种常见的错误是在一个`Activity`或者`Fragment`中编写所有代码。这些基于界面的类应仅包含处理界面和操作系统交互的逻辑。应该使这些类尽可能的保持精简，来提高这些类的可测试性。

为了提供令人满意的用户体验和更易于管理的应用维护体验，应该减少对他们的依赖。

#### 通过数据模型驱动界面

这也是一个==重要原则==

应该通过数据模型驱动界面（最好是持久化模型），数据模型代表应用的数据，它们应该独立于应用中的界面元素和其他组件。这意味着它们与界面和应用组件的生命周期没有关联，但是仍然会在操作系统决定从内存中移除应用的进程时被销毁。

持久化模型是理想之选

- 如果Android操作系统销毁应用来释放资源，用户不会丢失数据
- 当网络连接不稳定或者不可用的时候，应用会继续工作

如果应用架构以数据模型类为基础，应用会更便于测试，更加稳定可靠。

#### 单一数据源

在应用中定义新数据类型时，应分配单一数据源（SSOT）。SSOT是该数据的所有者，而且只有此SSOT可以修改或转变该数据。为了实现这一点，SSOT会以不可变类型公开数据，而且为了修改数据，SSOT会公开函数或接收其他类型可以调用的事件。

此模式具有多种优势；

- 将对特定类型数据的所有更改集中到一处
- 保护数据，防止其他类型篡改此数据
- 更易于跟踪对数据的更改，因此，更容易发现bug。

在离线优先应用中，应用数据的单一数据源通常是数据库。在其他某些情况下，单一数据源可以是ViewModel甚至是界面。

#### 单向数据流

单一数据源原则常常与单向数据流（UDF）模式一起使用。在UDF中，**状态**就朝一个方向流动，修改数据的**事件**朝相反方向流动。

此模式可以更好地保证数据一致性，不易出错、更加易于调试，并且具备SSOT模式的所有优势。

### 推荐的应用架构

每个应用应至少有两个层：

- 界面层 - 在屏幕上显示应用数据。
- 数据层 - 包括应用的业务逻辑并公开应用数据。

可以额外添加一个名为“网域层”的架构层，以简化和重复使用界面层与数据层之间的交互。

![image-20230327202455691](D:\work\docs\learning-log\2023-3-24-Android.assets\image-20230327202455691.png)

#### 现代应用架构

采用以下方法及其他一些方法：

- 反应式分层架构
- 应用的所有层中的单向数据流（UDF）。
- 包含状态容器的界面层，用于管理界面的复杂性。
- 协程和数据流
- 依赖项注入最佳实践。

##### 界面层

界面层的作用是在屏幕上显示应用数据。

界面层：

- 在屏幕上呈现数据的界面数据。可以使用View或Jetpack Compose函数构建这些元素。
- 用于存储数据、向界面提供数据以及处理逻辑的状态容器。

##### 数据层

应用的数据层包含`业务逻辑`。业务逻辑决定应用的价值，它包含决定应用如何创建、存储和更改数据的规则。

数据层由多个存储库组成，其中每个存储库都可以包含零到多个数据源。该为应用中处理的每个不同类型的数据分别创建一个存储库类。

存储库负责以下任务：

- 向应用的其他部分公开数据。
- 集中处理数据变化。
- 解决多个数据源之间的冲突。
- 对应用其他部分的数据源进行抽象化处理。
- 包含业务逻辑。

每个数据源类应仅仅负责处理一个数据源，数据源可以文件、网络来源或本地数据库。数据源类应用与数据操作系统之间的桥梁。

##### 网域层

网域层是位于界面与数据层之间的可选层。

网域层负责封装复杂的业务逻辑，或者由多个ViewModel重复使用的简单业务逻辑。这一层是可选的，因为并非所有应用都有这类需求。

### 管理组件之间的依赖关系

应用中的类要依赖其他类才能正常工作。

- 依赖注入（DI）：依赖注入使类能够定义其依赖项而不构造它们。在运行时，另一个类负责提供这些依赖项。
- 服务定位器：服务定位器模式提供一个注册表，类可以从中获取其依赖项而不构造它们。

可以借助这些模式来扩展代码，因为它们可以提供清晰的依赖项管理模式。

### 常见的最佳实践

无论是在多个Activity或Fragment之间传递数据，检索远程数据并将其保留在本地以离线模式下使用，还是复杂应用遇到的任何其他常见情况。

- 不要将数据存储在应用组件中。
- 减少对Android类的依赖。
- 在应用的各个模块之间设定明确定义的职责界限。
- 尽量少公开每个模块中的代码。
- 专注于应用的独特核心，以使其从其他应用中脱颖而出。
- 考虑如何使应用的每个部分可独立测试。
- 类型负责其并发政策。
- 保留尽可能多的相关数据和最新数据。

### 架构的优势

- 提高整个应用的可维护性、质量和稳健性。
- 允许应用扩缩。
- 架构能使项目保持一致性。
- 更加易于测试。良好的架构鼓励使用更简单的类型，这些类型通常更易于测试。
- 可以使用明确定义的流程有条理地调查bug。
- 在架构方面的投入也会对用户产生直接积极影响，用户能从更稳定的应用中获益。

## 有关Android架构的建议

### 分层架构

分层架构有助于实现关注点分离。这种架构可以通过数据模型来驱动界面，符合单一可信来源原则，也符合单向数据流原则。

- 使用明确定义的数据层
- 使用明确定义的界面层
- 数据层应该使用代码库老公开数据
- 使用协程和数据流
- 使用网域层（大型应用中）

### 界面层

界面层的作用是在屏幕上显示应用数据，并充当主要的用户互动点。

- 遵循单向数据流（UDF）原则
- 如果AAC ViewModel的优势适用于应用
- 使用生命周期感知型界面状态收集方式
- 请勿将ViewModel的事件发送到界面

### ViewModel

- ViewModel应该与Android生命周期无关
- 使用协程和数据流
- 在屏幕级别使用ViewModel
- 在可重复使用的界面组件中使用普通状态容器类
- 请勿使用AndroidViewModel
- 公开界面状态

### 生命周期

- 请勿替换activity或fragment中的生命周期方法

### 处理依赖关系

- 使用依赖项注入
- 在必要时将作用域限定为某个组件
- 使用Hilt（可选）

### 测试

- 了解要测试的内容
- 尽量采用虚假实现，而非模拟实现
- 测试StateFlow

### 模型

- 对于复杂的应用，要为每个层都创建一个模型

### 命名惯例

- 命名方法
- 为属性命名
- 为数据流命名
- 为接口实现来命名

## 构建Compose界面

在Compose中，界面是不可变的，在绘制后是无法进行更新，可以控制的是界面的状态，每当界面状态发生改变的时候，Compose都会**重新构建界面数中已经更改的部分**。可组合项可以接受状态并且公开事件，

由于可组合项接受状态并且公开事件，因此**单向数据流**非常适合Jetpack Compose。

### 单向数据流

又叫UDF，这是一种设计模式，在该模式下，状态向下流动，事件向上流动，通过这种单向数据流，就可以将在界面中显示状态的可组合向与应用中存储换个更改状态的部分分离开来。

界面更新循环：

- **事件**：界面的某一个部分生成一个事件，并且向上传递。
- **更新状态**：事件处理脚本可能会更改状态
- **显示状态**：状态向下传递状态，界面显示此状态。

优势：

- **可测试性**
- **状态封装**
- **界面一致性**

### Compose中的事件

应用的每项输入都应表示为事件：点按、文本更改、计时器或者其他更新。当这些事件耿欣界面的状态时，ViewModel应负责处理这些事件并且更新界面状态。

界面层绝不应更改事件处理脚本之外的状态，因为这样做可能会导致应用出现不一致和bug。

最好为状态和事件处理脚本lambda传递`不可变值`。

优势：

- 提高可重用性
- 确保界面不会直接更改状态的值
- 避免并发问题，因为这样的话，就可以确保不会从其他线程修改状态
- 通常情况下，还可以降低代码的复杂性

### ViewModel、状态和事件

借助`ViewModel`和`mutableStateOf`，如果出现下列任一情况，还是可以使用单向数据流

1. 界面状态通过`StateFlow`或者`LiveData`等可观察的状态容器公开
2. `ViewModel`处理来自应用界面或其他层的事件，并且根据事件更新状态容器

## ViewModel

ViewModel类时一种业务逻辑或屏幕级状态容器。用于将状态公开给界面，以及封装相关的业务逻辑，它主要优点是，它可以缓存状态，并可在配置更改后持久保留相应状态，这意味着在Activity之间导航时或进行配置更改后，界面将无需重新提取数据。

ViewModel的优势

ViewModel的替代方案是保存要在界面中显示的数据的普通类，在Activity或Navigation目的地之间导航时，这可能会造成问题，此时，如果不利用保存实例状态机制存储相应数据，系统便会销毁相应数据，ViewModel提供一个便携的数据持久性API。

优势：

- 允许持久保留界面状态
- 可以提供对业务逻辑的访问权限

### 持久性

ViewModel允许数据在ViewModel持有的状态和ViewModel触发的操作结束后继续存在。这种缓存意味着在常见的配置更改完成后，无需重新提取数据。

### 作用域

实例化ViewModel时，会向其传递实现ViewModelStoreOwner接口的对象。

有一系列类是ViewModelStoreOwner接口的直接或间接子类。

直接子类为`ComponentActivity`、`Fragment`和`NavBackStackEntry`。

当ViewModel的作用域Fragment或Activity被销毁的时，异步工作会在作用域限定到该Fragment或Activity的ViewModel中继续进行，这是持久化的关键。

### SaveStateHandle

借助SaveStateHandle，不仅可以在更改配置后持久保留数据，还可以在进程重新创建过程中持久保留数据，也就是说，即使用户关闭应用，稍后又打开，界面的状态也可以保持不变。

### 对业务逻辑的访问权限

大多数的业务逻辑都存在在数据层中，但界面层也可以包含业务逻辑，当合并多个代码库中的数据以创建屏幕界面状态时，或特定类型的数据不需要数据层时，情况就是如此。

ViewModel是在界面层处理业务逻辑的正确位置，当需要应用业务逻辑来修改应用数据时，ViewModel还负责处理事件并将其委托给层次结构中的其他层。

### Jetpack Compose

使用Jetpack Compose时，ViewModel是向可组合项公开屏幕界面状态的主要方式。在混合应用中，Activity和Fragment仅用于托管可组合函数，这与以往的方法不同；过去，创建包含activity和fragment且可重复使用的界面部分没有这么简单和直观，因此这类部分在作为界面控制器时会更加活跃。

将ViewModel与Compose一起使用时，最重要的是，无法将ViewModel的作用域限定为可组合项，这是因为可组合项不属于`ViewModelStoreOwner`。组合中同一可组合项的两个实例，或者在同一个下访问同一ViewModel类型的两个不同的可组合项，将会收到相同的ViewModel实例，这通常不是预期的行为。

如果要在 Compose 中利用 ViewModel 的优势，在 fragment 或 activity 中托管每个屏幕，或者使用 Compose Navigation，并在尽可能靠近 Navigation 目的地的可组合函数中使用 ViewModel。这是因为，这可以将 ViewModel 的作用域限定为 Navigation 目的地、Navigation 图表、activity 和 fragment。

### ViewModel的生命周期

它的生命周期与其作用域直接关联。ViewModel会一直保留在内存中，直到其作用域`ViewModelStoreOwner`消失。

## 界面层

界面的作用是在屏幕上显示应用数据，并充当主要的用户互动点。每当数据发生变化的时候，无论是因为用户互动，还是因为外部输入，界面都应随之更新，以反映这些状态。实际上，界面是从数据层获取的应用状态的直观呈现。

从数据层获取的应用数据的格式通常不同于需要显示的信息的格式。无论应用的是什么逻辑，都需要向界面传递完全呈现界面所需的所有信息。界面层是一个流水线，负责将应用数据变化转换为界面可以呈现的形式，然后将其显示出来。

![image-20230328154222536](D:\work\docs\learning-log\2023-3-24-Android.assets\image-20230328154222536.png)

### 线程处理和并发

在ViewModel中执行的所有工作都应具有主线程安全性（即从主线程调用是安全的）。这是因为数据层和网域层负责将工作移至其他线程。

如果ViewModel执行长时间运行的操作，则还要负责将相应逻辑移至后台线程。Kotlin协程是管理并发操作的绝佳方式，Jetpack架构组件则为其提供内置支持。

### 导航

应用导航的变化通常是由类似于事件的发出操作驱动的。这一类的触发器的使用方式应与使用界面状态的所使用的方法相同，不过实现遵从导航组件。

### Paging

Paging库通常通过一个称为PagingData的类型在界面中使用，由于PagingData表示并包含可以随时间变化的内容，因此它不应为不可变界面状态表示。

### 动画

为了流畅的顶级导航过渡，需要等待第二个屏幕加载数据，然后再启动动画。

## 界面事件

"界面事件"是指应由界面或ViewModel在界面层处理的操作。最常见的事件类型是"用户事件"。用户通过与应用互动来生成用户事件。

## 导航

导航是指支持用户导航、进入和退出应用中不同内容片段的交互。

导航组件由以下三个关键部分组成：

- 导航图：在一个集合位置包含所有导航相关信息的XML资源。这包括应用内所有单个内容区域（称为目标）以及用户可以通过应用获取的可能路径。
- NavHost：显示导航图中目标的空白容器。导航组件包含一个默认NavHost实现（NavHostFragment），可显示Fragment目标。
- NavController：在NavHost中管理应用导航的对象。当用户在整个应用中移动时，NavController会安排NavHost中目标内容的交换。

导航组件提供各种其他优势：

- 处理Fragment事务
- 默认情况下，正确处理往返操作
- 为动画和转换提供标准化资源
- 实现和处理深层链接
- 包括导航界面模式
- Safe Args 可在目标之间导航和传递数据时提供类型安全的Gradle插件
- ViewModel支持

## 状态容器和界面状态

单向数据流（UDF）可作为为界面层提供和管理界面状态的方式。

### 界面状态

界面状态是描述界面的属性。界面状态有两种类型：

- **屏幕界面状态**
- **界面元素状态**

## 生命周期

为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：`onCreate()`、`onStart()`、`onResume()`、`onPause()`、`onStop()` 和 `onDestroy()`。当 Activity 进入新状态时，系统会调用其中每个回调。

### onCreate（）

会在系统首次创建Activity时触发，Activity会在创建后进入“已创建”状态。

### onStart（）

当Activity进入“已开始”状态时，系统会调用此回调。`onCreate()`调用使Activity对用户可见，因为应用会为Activity进入前台并支持互动做准备。

`onCreate()`方法会非常迅速地完成，并且于“已创建”状态一样，Activity不会一直处于"已开始"状态。

### onResume（）

Activity会在进入"已恢复"状态时来到前台，然后系统调用`onResume()`回调。

### onPause（）

系统将此方法视为用户将要离开 Activity 的第一个标志（尽管这并不总是意味着 Activity 会被销毁）；此方法表示 Activity 不再位于前台（尽管在用户处于多窗口模式时 Activity 仍然可见）。

### onStop（）

如果Activity 不再对用户可见，说明其已进入“已停止”状态，因此系统将调用 `onStop()` 回调。

### onDestroy（）

销毁 Activity 之前，系统会先调用 `onDestroy()`。系统调用此回调的原因如下：

1. Activity 即将结束（由于用户彻底关闭 Activity 或由于系统为 Activity 调用 `finish()`，或者
2. 由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁 Activity

## 依赖项注入

依赖项注入(DI)是一种广泛用于编程的技术，非常适用于Android开发。

优势：

- 重用代码
- 易于重构
- 易于测试

### 依赖项注入

类通常需要引入其他类。这些必需类称为依赖项。

类可以通过以下三种方式获取所需的对象：

1. 类构造其所需的依赖项。
2. 从其他地方抓取。
3. 以参数形式提供（==这就是依赖项注入==）

依赖项注入会为应用提供以下优势：

- 重用类以及分离依赖项：更容易换掉依赖项的实现。由于控制反转，代码重用得以改进，并且类不再控制其依赖项的创建方式，而是支持任何配置。
- 易于重构：依赖项成为 API Surface 的可验证部分，因此可以在创建对象时或编译时进行检查，而不是作为实现详情隐藏。
- 易于测试：类不管理其依赖项，因此在测试时，可以传入不同的实现以测试所有不同用例。

## 工作流程

1. 设置工作区
2. 编写应用
3. 构建和运行
4. 调试、分析和测试
5. 发布

## Retrofit

是一个RESTful的HTTP网络请求框架的封装，网络请求的工作本质上是OkHttp完成，而Retrofit仅负责网络请求接口的封装。

OkHttp是一个高效的HTTP客户端，是目前Android使用最广泛的网络框架
